<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>유튜브 알랑가 IT 꿀팁(구글 TTS 한국어 변환기)</title>
    <style>
        /* 기존 style.css 내용을 여기에 붙여넣거나, 별도 파일로 관리하여 링크하세요. */
        /* 예시로 기본적인 스타일만 추가합니다. */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; background-color: #f4f7f6; margin: 0; padding: 20px; }
        .main-layout { display: flex; max-width: 1200px; margin: 0 auto; background-color: #fff; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); overflow: hidden; }
        .sidebar-iframe { flex: 0 0 200px; border: none; height: 100vh; /* 예시 높이 */ }
        .content-wrapper { flex-grow: 1; padding: 30px; }
        .container { max-width: 800px; margin: 0 auto; }
        h1, h2, h3 { color: #2c3e50; }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
        textarea, input[type="text"], input[type="password"], input[type="number"], select {
            width: calc(100% - 20px);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
            box-sizing: border-box;
        }
        textarea { min-height: 120px; resize: vertical; }
        .btn-primary, .btn-secondary, .btn-accent {
            padding: 10px 18px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin-right: 10px;
            transition: background-color 0.2s;
        }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-primary:hover { background-color: #0056b3; }
        .btn-secondary { background-color: #6c757d; color: white; }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-accent { background-color: #ffc107; color: #333; }
        .btn-accent:hover { background-color: #e0a800; }
        .btn-group { margin-top: 20px; display: flex; flex-wrap: wrap; gap: 10px;}
        .status { margin-top: 20px; padding: 10px; border-radius: 4px; background-color: #e9ecef; color: #333; }
        audio { width: 100%; margin-top: 20px; }
        .tooltip { position: relative; display: inline-block; cursor: help; margin-left: 5px; }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
        }
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #555 transparent transparent transparent;
        }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
        .api-key-input-wrapper { display: flex; align-items: center; }
        .api-key-input { flex-grow: 1; margin-right: 10px; }
        .api-key-toggle-btn {
            background: none;
            border: 1px solid #ddd;
            padding: 10px;
            cursor: pointer;
            border-radius: 4px;
        }
        .tabs { display: flex; margin-bottom: 20px; border-bottom: 1px solid #ddd; }
        .tab { padding: 10px 15px; cursor: pointer; border: 1px solid transparent; border-bottom: none; margin-bottom: -1px; }
        .tab.active { border-color: #ddd; border-bottom-color: #fff; background-color: #fff; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .ssml-tags { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; }
        .ssml-tag {
            background-color: #e9ecef;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .ssml-tag:hover { background-color: #d1d8e0; }
        .char-counter-display { font-size: 0.85em; color: #666; text-align: right; margin-top: 5px; }
        .voice-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; }
        .control-group input[type="range"] { width: calc(100% - 70px); vertical-align: middle; margin-right: 10px;}
        .control-group span { display: inline-block; width: 50px; text-align: right;}
        footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; text-align: center; font-size: 0.85em; color: #777; }

        /* 새로 추가될 텍스트 분할 영역 스타일 */
        #original-text-section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #eee;
        }
        #segmented-texts-container {
            margin-top: 30px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .text-segment {
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .text-segment label {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #34495e;
        }
        .text-segment textarea {
            min-height: 80px;
            background-color: #fcfcfc;
            border: 1px solid #dcdcdc;
        }
        .segment-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .download-status {
            margin-left: auto; /* 우측 정렬 */
            font-size: 0.9em;
            color: #555;
            min-width: 100px;
            text-align: right;
        }
        .download-status.success { color: green; font-weight: bold; }
        .download-status.error { color: red; font-weight: bold; }
        .download-status.pending { color: orange; }
    </style>
</head>
<body>
    <div class="main-layout">
        <iframe 
            id="left-iframe" 
            class="sidebar-iframe" 
            src="https://ai.okko.kr/bookmark/index1.php" 
            title="좌측 사이드바">
        </iframe>

        <div class="content-wrapper">
            <div class="container">
                <div class="main-header">
                    <h1>구글 TTS 한국어 변환기 (대본 분할 기능 추가)</h1>
                    <div id="compareTarget" style="text-align: center;"> 
                        <a href="https://www.youtube.com/@okko-kr" target="_blank">유튜브 알랑가 IT 꿀팁(구글 텍스트 음성변환)</a>
                    </div>
                    <p class="app-description" style="margin-top: 8px;">
                        구글의 Text-to-Speech API를 활용하여 텍스트를 자연스러운 한국어 음성으로 변환해보세요. 긴 대본도 자동으로 분할하여 변환합니다.
                    </p>
                </div>

                <div class="api-key-section">
                    <div class="form-group">
                        <label for="api-key">구글 TTS API 키 입력 
                            <span class="tooltip">
                                <span class="tooltiptext">구글 클라우드 콘솔에서 API 키를 생성한 후 여기에 입력하세요. API 키는 로컬에만 저장되며 서버로 전송되지 않습니다.</span>
                            </span>
                        </label>
                        <div class="api-key-input-wrapper">
                            <input type="password" class="api-key-input" id="api-key" placeholder="API 키를 입력하세요">
                            <button type="button" id="toggle-api-key-visibility" class="api-key-toggle-btn" aria-label="API 키 보기">◉</button>
                        </div>
                        <p style="font-size: 12px; margin-top: 8px; color: var(--light-text);">
                            * API 키는 로컬 스토리지에 저장되며, 외부로 전송되지 않습니다.
                        </p>
                    </div>
                </div>

                <div id="original-text-section">
                    <h2>긴 대본 입력</h2>
                    <div class="form-group">
                        <label for="original-transcript">전체 대본을 입력하세요 (문장 단위로 자동 분할됩니다)</label>
                        <textarea id="original-transcript" placeholder="유튜브 영상의 대본 전체를 여기에 붙여넣으세요..."></textarea>
                        <div class="char-counter-display" id="original-transcript-counter">
                            글자 수: 0 | 바이트 수: 0
                        </div>
                    </div>
                    <button id="process-transcript-btn" class="btn-primary">대본 분할 및 준비</button>
                </div>

                <div id="segmented-texts-container">
                    <h2>분할된 텍스트 청크 (<5000 바이트)</h2>
                    <p id="no-segments-message" style="color: #777; margin-top: 15px;">
                        '대본 분할 및 준비' 버튼을 눌러 대본을 분할하세요.
                    </p>
                    </div>

                <h3 style="margin-top: 24px; margin-bottom: 16px;">음성 설정 (전역 적용)</h3>
                <div class="voice-controls">
                    <div class="control-group">
                        <label for="voice-select">음성 모델</label>
                        <select id="voice-select">
                            <option value="ko-KR-Standard-A">ko-KR-Standard-A (여성)</option>
                            <option value="ko-KR-Standard-B">ko-KR-Standard-B (여성)</option>
                            <option value="ko-KR-Standard-C">ko-KR-Standard-C (남성)</option>
                            <option value="ko-KR-Standard-D">ko-KR-Standard-D (남성)</option>                            
                            <option value="ko-KR-Neural2-A">ko-KR-Neural2-A (여성)</option>
                            <option value="ko-KR-Neural2-B">ko-KR-Neural2-B (여성)</option>
                            <option value="ko-KR-Neural2-C">ko-KR-Neural2-C (남성)</option>
                            <option value="ko-KR-Wavenet-A">ko-KR-Wavenet-A (여성)</option>
                            <option value="ko-KR-Wavenet-B">ko-KR-Wavenet-B (여성)</option>
                            <option value="ko-KR-Wavenet-C">ko-KR-Wavenet-C (남성)</option>
                            <option value="ko-KR-Wavenet-D">ko-KR-Wavenet-D (남성)</option>
                            <option value="ko-KR-Chirp3-HD-Aoede">한국어 (Chirp3: HD - 여성 Aoede)</option>
                            <option value="ko-KR-Chirp3-HD-Charon">한국어 (Chirp3: HD - 남성 Charon)</option>
                            <option value="ko-KR-Chirp3-HD-Fenrir">한국어 (Chirp3: HD - 남성 Fenrir)</option>
                            <option value="ko-KR-Chirp3-HD-Kore">한국어 (Chirp3: HD - 여성 Kore)</option>
                            <option value="ko-KR-Chirp3-HD-Leda">한국어 (Chirp3: HD - 여성 Leda)</option>
                            <option value="ko-KR-Chirp3-HD-Orus">한국어 (Chirp3: HD - 남성 Orus)</option>
                            <option value="ko-KR-Chirp3-HD-Puck">한국어 (Chirp3: HD - 남성 Puck)</option>
                            <option value="ko-KR-Chirp3-HD-Zephyr">한국어 (Chirp3: HD - 여성 Zephyr)</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label for="rate-slider">재생 속도</label>
                        <input type="range" id="rate-slider" min="0.25" max="4.0" step="0.05" value="1.0">
                        <span id="rate-value">1.0</span>
                    </div>

                    <div class="control-group">
                        <label for="pitch-slider">음높이</label>
                        <input type="range" id="pitch-slider" min="-20" max="20" step="1" value="0">
                        <span id="pitch-value">0</span>
                    </div>

                    <div class="control-group">
                        <label for="volume-slider">볼륨</label>
                        <input type="range" id="volume-slider" min="-96" max="16" step="1" value="0">
                        <span id="volume-value">0</span>
                    </div>
                </div>

                <footer>
                    <p>구글 Text-to-Speech API를 사용하여 제작되었습니다. TTS API 사용은 구글 클라우드 콘솔에서 할당량과 과금 정책을 확인하세요.</p>
                </footer>
            </div> </div> <iframe 
            id="right-iframe" 
            class="sidebar-iframe" 
            src="https://ai.okko.kr/bookmark/index.php" 
            title="우측 사이드바">
        </iframe>
    </div> <script>
        // 이 안에 모든 JavaScript 코드를 작성할 것입니다.
        // 기존 ai.okko.kr.html 파일의 synthesizeSpeech_local, base64ToBlob_local 함수와 유틸리티 함수들을 포함합니다.

        // 기존 base64ToBlob_local 함수 (변경 없음)
        function base64ToBlob_local(_0x250c9e,_0xe43810){const _0x284da4=a0_0x34c5;try{const _0x12ece4=atob(_0x250c9e),_0x38c40b=[];for(let _0x5eeb5f=0x0;_0x5eeb5f<_0x12ece4[_0x284da4(0x1f3)];_0x5eeb5f+=0x200){const _0x52e634=_0x12ece4[_0x284da4(0x205)](_0x5eeb5f,_0x5eeb5f+0x200),_0x254127=new Array(_0x52e634[_0x284da4(0x1f3)]);for(let _0x2850c0=0x0;_0x2850c0<_0x52e634['length'];_0x2850c0++){_0x254127[_0x2850c0]=_0x52e634[_0x284da4(0x204)](_0x2850c0);}const _0x214e00=new Uint8Array(_0x254127);_0x38c40b['push'](_0x214e00);}return new Blob(_0x38c40b,{'type':_0xe43810});}catch(_0x204b62){return console[_0x284da4(0x203)]('Error\x20in\x20base64ToBlob_local:',_0x204b62),null;}}

        // 기존 synthesizeSpeech_local 함수 (변경 없음)
        async function synthesizeSpeech_local(_0x3510d9,_0x11db89){const _0x1553d3=a0_0x34c5,{textToConvert:_0x185084,inputType:_0x175e7d,voice:_0x110719,rate:_0x6cc6f1,pitch:_0x35bc1f,volumeGainDb:_0x2b41fb,isChirpModel:_0x78887a}=_0x11db89;let _0x49336f={};if(_0x175e7d===_0x1553d3(0x1f5)){if(!_0x185084)return{'error':_0x1553d3(0x1f2)};_0x49336f[_0x1553d3(0x1f5)]=_0x185084;}else{if(_0x175e7d===_0x1553d3(0x1ee)){if(!_0x185084)return{'error':_0x1553d3(0x1f4)};if(!_0x185084[_0x1553d3(0x1ed)]('<speak>')||!_0x185084[_0x1553d3(0x1f6)](_0x1553d3(0x20b)))return{'error':_0x1553d3(0x1fd)};_0x49336f[_0x1553d3(0x1ee)]=_0x185084;}else return{'error':'알\x20수\x20없는\x20입력\x20타입입니다.'};}const _0x39fd65=_0x78887a?_0x1553d3(0x1fb):'v1',_0x27c93b='https://texttospeech.googleapis.com/'+_0x39fd65+_0x1553d3(0x208)+_0x3510d9,_0xc278e2={'input':_0x49336f,'voice':{'languageCode':_0x1553d3(0x1f0),'name':_0x110719},'audioConfig':{'audioEncoding':'MP3','speakingRate':_0x6cc6f1,'volumeGainDb':_0x2b41fb}};!_0x78887a&&_0xc278e2[_0x1553d3(0x1f7)]&&(_0xc278e2[_0x1553d3(0x1f7)][_0x1553d3(0x1fe)]=_0x35bc1f);try{const _0x43200b=await fetch(_0x27c93b,{'method':'POST','headers':{'Content-Type':'application/json'},'body':JSON[_0x1553d3(0x1ef)](_0xc278e2)}),_0x8012ed=await _0x43200b['json']();if(!_0x43200b['ok']){const _0x52579b=_0x8012ed[_0x1553d3(0x203)]&&_0x8012ed[_0x1553d3(0x203)][_0x1553d3(0x209)]?_0x8012ed[_0x1553d3(0x203)][_0x1553d3(0x209)]:_0x1553d3(0x1f1);return console[_0x1553d3(0x203)](_0x1553d3(0x1f8),_0x8012ed),{'error':_0x1553d3(0x1f9)+_0x52579b+'\x20(코드:\x20'+_0x43200b['status']+')','details':_0x8012ed};}if(!_0x8012ed[_0x1553d3(0x201)])return{'error':_0x1553d3(0x1ff)};return{'audioContent':_0x8012ed[_0x1553d3(0x201)]};}catch(_0xfd9d59){return console['error'](_0x1553d3(0x1ec),_0xfd9d59),{'error':_0x1553d3(0x206)+_0xfd9d59[_0x1553d3(0x209)]};}}

        // 기존 난독화된 유틸리티 함수들 (필요시 원래 스크립트 파일에서 복사)
        // 안전한 변환을 위해 필요한 유틸리티 함수들을 여기에 추가합니다.
        (function(_0x1c09aa,_0x173db3){const _0x1a15fd=a0_0x34c5,_0x591b8a=_0x1c09aa();while(!![]){try{const _0x4094cd=-parseInt(_0x1a15fd(0x1e9))/0x1+parseInt(_0x1a15fd(0x1ea))/0x2+parseInt(_0x1a15fd(0x207))/0x3+-parseInt(_0x1a15fd(0x202))/0x4+-parseInt(_0x1a15fd(0x20a))/0x5*(parseInt(_0x1a15fd(0x1fa))/0x6)+parseInt(_0x1a15fd(0x1eb))/0x7*(-parseInt(_0x1a15fd(0x200))/0x8)+parseInt(_0x1a15fd(0x1fc))/0x9;if(_0x4094cd===_0x173db3)break;else _0x591b8a['push'](_0x591b8a['shift']());}catch(_0x5efc9c){_0x591b8a['push'](_0x591b8a['shift']());}}}(a0_0x4dd2,0x23229));function a0_0x34c5(_0x56e08f,_0x13f962){const _0x4dd2c6=a0_0x4dd2();return a0_0x34c5=function(_0x34c5e7,_0xb063c7){_0x34c5e7=_0x34c5e7-0x1e9;let _0x4b5dcf=_0x4dd2c6[_0x34c5e7];if(a0_0x34c5['rqwccm']===undefined){var _0x4eca2f=function(_0x3510d9){const _0x11db89='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=';let _0x185084='',_0x175e7d='';for(let _0x110719=0x0,_0x6cc6f1,_0x35bc1f,_0x2b41fb=0x0;_0x35bc1f=_0x3510d9['charAt'](_0x2b41fb++);~_0x35bc1f&&(_0x6cc6f1=_0x110719%0x4?_0x6cc6f1*0x40+_0x35bc1f:_0x35bc1f,_0x110719++%0x4)?_0x185084+=String['fromCharCode'](0xff&_0x6cc6f1>>(-0x2*_0x110719&0x6)):0x0){_0x35bc1f=_0x11db89['indexOf'](_0x35bc1f);}for(let _0x78887a=0x0,_0x49336f=_0x185084['length'];_0x78887a<_0x49336f;_0x78887a++){_0x175e7d+='%'+('00'+_0x185084['charCodeAt'](_0x78887a)['toString'](0x10))['slice'](-0x2);}return decodeURIComponent(_0x175e7d);};a0_0x34c5['lbxaFa']=_0x4eca2f,_0x56e08f=arguments,a0_0x34c5['rqwccm']=!![];}const _0x42df47=_0x4dd2c6[0x0],_0x18aecf=_0x34c5e7+_0x42df47,_0x6378b8=_0x56e08f[_0x18aecf];return!_0x6378b8?(_0x4b5dcf=a0_0x34c5['lbxaFa'](_0x4b5dcf),_0x56e08f[_0x18aecf]=_0x4b5dcf):_0x4b5dcf=_0x6378b8,_0x4b5dcf;},a0_0x34c5(_0x56e08f,_0x13f962);}function a0_0x4dd2(){const _0xbd4b7c=['u1nntoYDGca8C3bLywS+io2dNoQ3UoUHNcdSI5ZSNPhTLzJQS6aGpc9ZCgvHAZ4G7yoC6RE466gCioUbNEUcMoYvVcdTLANRI4JRI6qU','CgL0y2G','qvbjioYDKEUlTEYxKcdSMktRLjtSMkqG7l2y7ywq7lIG6RcaioYxHUYkTEUlIoUlPc4','offUCg11sq','yxvKAw9dB250zw50','mZm5odH4AxfUy3e','zxjYB3i','y2HHCKnVzgvbDa','C2XPy2u','64sK7yQ47jUm7ygSioYyPoULMcdRMjdRIPqGqvbjioYALoYYRsdSI6tTJkG6ia','mZm1nZy2uvzeAKfe','l3rLEhq6C3LUDgHLC2L6zt9RzxK9','BwvZC2fNzq','otKZntCWsM9UvM1W','pc9ZCgvHAZ4','mtqWotHIz1jZq1u','mtK0mZbyChvSvhe','mtKZmZKZowTUEeX1Ea','tMv0D29YAYbVCIbgzxrJAcbfCNjVCIbPBIbZEw50AgvZAxPLu3bLzwnOx2XVy2fSoG','C3rHCNrZv2L0Aa','C3nTBa','C3rYAw5NAwz5','A28Ts1i','qvbjioYyPoULMcdRSjZSG53TLOJSIRxRI4JRI6qU','7ywn7iQK7yQ466w8ioYEHEUGPE2vToYJVoYeUoYALc4','BgvUz3rO','u1nntoYDHcdSNOxROkxTLBtSO7ZSHlJSMPqU','Dgv4Da','zw5KC1DPDgG','yxvKAw9dB25MAwC','qvbjievYCM9YigLUihn5BNrOzxnPEMvtCgvLy2HFBg9JywW6','qvbjioYyPoULMdOG','nLrLu0LcqW','DJfIzxrHmq','ndy3odC1ohzLBwLLua'];a0_0x4dd2=function(){return _0xbd4b7c;};return a0_0x4dd2();}
        // 여기까지 기존 스크립트의 난독화된 유틸리티 코드

        document.addEventListener('DOMContentLoaded', () => {
            const apiKeyInput = document.getElementById('api-key');
            const toggleApiKeyVisibilityBtn = document.getElementById('toggle-api-key-visibility');
            const originalTranscriptInput = document.getElementById('original-transcript');
            const originalTranscriptCounter = document.getElementById('original-transcript-counter');
            const processTranscriptBtn = document.getElementById('process-transcript-btn');
            const segmentedTextsContainer = document.getElementById('segmented-texts-container');
            const noSegmentsMessage = document.getElementById('no-segments-message');

            const voiceSelect = document.getElementById('voice-select');
            const rateSlider = document.getElementById('rate-slider');
            const rateValueSpan = document.getElementById('rate-value');
            const pitchSlider = document.getElementById('pitch-slider');
            const pitchValueSpan = document.getElementById('pitch-value');
            const volumeSlider = document.getElementById('volume-slider');
            const volumeValueSpan = document.getElementById('volume-value');

            const MAX_BYTES_PER_CHUNK = 5000; // 최대 바이트 수 제한

            // 1. API 키 로컬 스토리지 관리
            // 페이지 로드 시 로컬 스토리지에서 API 키 불러오기
            const savedApiKey = localStorage.getItem('google-tts-api-key');
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
            }

            // API 키 입력 시 로컬 스토리지에 저장
            apiKeyInput.addEventListener('input', () => {
                localStorage.setItem('google-tts-api-key', apiKeyInput.value);
            });

            // API 키 가시성 토글
            toggleApiKeyVisibilityBtn.addEventListener('click', () => {
                if (apiKeyInput.type === 'password') {
                    apiKeyInput.type = 'text';
                    toggleApiKeyVisibilityBtn.textContent = '◉'; // 보이는 상태 표시
                } else {
                    apiKeyInput.type = 'password';
                    toggleApiKeyVisibilityBtn.textContent = '◉'; // 가려진 상태 표시
                }
            });

            // 2. 글자 수/바이트 수 카운터 함수
            function getByteLength(str) {
                return new TextEncoder().encode(str).length;
            }

            function updateCounter(textarea, counterDisplay) {
                const text = textarea.value;
                const charCount = text.length;
                const byteCount = getByteLength(text);
                counterDisplay.textContent = `글자 수: ${charCount} | 바이트 수: ${byteCount}`;
            }

            // 초기 로드 시 대본 입력란 카운터 업데이트
            updateCounter(originalTranscriptInput, originalTranscriptCounter);

            // 대본 입력란 내용 변경 시 카운터 업데이트
            originalTranscriptInput.addEventListener('input', () => {
                updateCounter(originalTranscriptInput, originalTranscriptCounter);
            });

            // 3. 음성 설정 슬라이더 값 업데이트
            rateSlider.addEventListener('input', () => {
                rateValueSpan.textContent = rateSlider.value;
            });
            pitchSlider.addEventListener('input', () => {
                pitchValueSpan.textContent = pitchSlider.value;
            });
            volumeSlider.addEventListener('input', () => {
                volumeValueSpan.textContent = volumeSlider.value;
            });

            // 4. 문장 분리 함수 (한국어 특화)
            function splitIntoSentences(text) {
                // 문장 끝을 나타내는 정규식: 마침표, 물음표, 느낌표 뒤에 공백이나 줄바꿈이 오는 경우
                // 또는 따옴표, 괄호 등 뒤에 오는 경우 포함
                const sentenceRegex = /([.?!]["']?\)?|\n)\s*/g;
                let sentences = text.split(sentenceRegex).filter(s => s && s.trim() !== '');

                // 정규식 split의 특성상 구분자가 결과 배열에 포함될 수 있으므로, 재조합
                let finalSentences = [];
                let currentSentence = '';

                for (let i = 0; i < sentences.length; i++) {
                    currentSentence += sentences[i];
                    // 다음 요소가 구분자이거나, 문장 끝에 도달하면
                    if (i + 1 < sentences.length && sentences[i+1].match(/^[.?!]["']?\)?|\n\s*$/)) {
                         // 다음 요소가 구분자이면 현재 문장 뒤에 붙여주고 다음 구분자는 건너뛰기
                         currentSentence += sentences[i+1];
                         finalSentences.push(currentSentence.trim());
                         currentSentence = '';
                         i++; // 다음 구분자 건너뛰기
                    } else if (i === sentences.length - 1) {
                         // 마지막 요소는 그대로 추가
                         finalSentences.push(currentSentence.trim());
                    }
                }
                return finalSentences.filter(s => s.length > 0);
            }

            // 5. 대본 분할 및 표시 함수
            processTranscriptBtn.addEventListener('click', () => {
                const originalText = originalTranscriptInput.value.trim();
                if (!originalText) {
                    alert('변환할 대본을 입력해주세요.');
                    return;
                }

                const sentences = splitIntoSentences(originalText);
                let currentChunk = '';
                let currentChunkByteLength = 0;
                let chunks = [];

                sentences.forEach((sentence, index) => {
                    const sentenceByteLength = getByteLength(sentence);

                    // 현재 청크에 이 문장을 추가하면 5000바이트를 초과하는지 확인
                    // 단, 현재 청크가 비어있고 문장 자체가 5000바이트를 초과하는 경우
                    // (이 경우 문장이 너무 길어서 5000바이트를 넘어감)
                    // 또는 현재 청크가 가득 찼는데 다음 문장을 추가하면 넘어가는 경우
                    if (currentChunkByteLength + sentenceByteLength > MAX_BYTES_PER_CHUNK && currentChunkByteLength > 0) {
                        chunks.push(currentChunk.trim());
                        currentChunk = '';
                        currentChunkByteLength = 0;
                    }
                    
                    // 문장 자체가 5000바이트를 초과하는 경우, 경고하고 해당 문장을 단독 청크로 처리
                    if (sentenceByteLength > MAX_BYTES_PER_CHUNK) {
                        alert(`경고: "${sentence.substring(0, 50)}..." 문장이 ${MAX_BYTES_PER_CHUNK} 바이트를 초과합니다. 이 문장은 단독 청크로 처리됩니다.`);
                        chunks.push(sentence.trim());
                        currentChunk = ''; // 현재 청크 초기화
                        currentChunkByteLength = 0;
                    } else {
                        currentChunk += (currentChunk.length > 0 ? ' ' : '') + sentence; // 문장 사이에 공백 추가
                        currentChunkByteLength += (currentChunk.length > 0 ? getByteLength(' ') : 0) + sentenceByteLength; // 바이트 길이 업데이트
                    }
                });

                // 마지막 남은 청크 추가
                if (currentChunk.length > 0) {
                    chunks.push(currentChunk.trim());
                }

                displaySegmentedTexts(chunks);
            });

            function displaySegmentedTexts(chunks) {
                segmentedTextsContainer.innerHTML = ''; // 기존 내용 지우기
                if (chunks.length === 0) {
                    noSegmentsMessage.style.display = 'block';
                    return;
                }
                noSegmentsMessage.style.display = 'none';

                chunks.forEach((chunk, index) => {
                    const segmentDiv = document.createElement('div');
                    segmentDiv.className = 'text-segment';
                    segmentDiv.dataset.segmentIndex = index; // 인덱스 저장

                    const segmentLabel = document.createElement('label');
                    segmentLabel.textContent = `청크 ${index + 1} (바이트: ${getByteLength(chunk)})`;
                    segmentDiv.appendChild(segmentLabel);

                    const textarea = document.createElement('textarea');
                    textarea.id = `segment-text-${index}`;
                    textarea.value = chunk;
                    textarea.readOnly = false; // 사용자가 수정할 수 있도록
                    segmentDiv.appendChild(textarea);

                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'segment-actions';
                    
                    const convertBtn = document.createElement('button');
                    convertBtn.className = 'btn-primary convert-segment-btn';
                    convertBtn.textContent = '음성 변환';
                    convertBtn.dataset.segmentId = index;
                    actionsDiv.appendChild(convertBtn);

                    const downloadBtn = document.createElement('button');
                    downloadBtn.className = 'btn-secondary download-segment-btn';
                    downloadBtn.textContent = 'MP3 다운로드';
                    downloadBtn.dataset.segmentId = index;
                    downloadBtn.disabled = true; // 변환 후에 활성화
                    actionsDiv.appendChild(downloadBtn);

                    const statusSpan = document.createElement('span');
                    statusSpan.className = 'download-status';
                    statusSpan.id = `status-segment-${index}`;
                    actionsDiv.appendChild(statusSpan);

                    const audioPlayer = document.createElement('audio');
                    audioPlayer.controls = true;
                    audioPlayer.id = `audio-segment-${index}`;
                    actionsDiv.appendChild(audioPlayer);


                    segmentDiv.appendChild(actionsDiv);
                    segmentedTextsContainer.appendChild(segmentDiv);

                    // 각 텍스트 영역에 대한 카운터 추가 (선택 사항, 필요 시 추가)
                    // const counterDisplay = document.createElement('div');
                    // counterDisplay.className = 'char-counter-display';
                    // segmentDiv.appendChild(counterDisplay);
                    // updateCounter(textarea, counterDisplay);
                    // textarea.addEventListener('input', () => updateCounter(textarea, counterDisplay));
                });

                // 각 세그먼트의 '음성 변환' 버튼에 이벤트 리스너 연결
                document.querySelectorAll('.convert-segment-btn').forEach(button => {
                    button.addEventListener('click', async (event) => {
                        const segmentId = event.target.dataset.segmentId;
                        const segmentTextarea = document.getElementById(`segment-text-${segmentId}`);
                        const audioPlayer = document.getElementById(`audio-segment-${segmentId}`);
                        const downloadBtn = document.querySelector(`.download-segment-btn[data-segment-id="${segmentId}"]`);
                        const statusSpan = document.getElementById(`status-segment-${segmentId}`);

                        const textToConvert = segmentTextarea.value;
                        const apiKey = apiKeyInput.value;

                        if (!apiKey) {
                            alert('API 키를 먼저 입력해주세요.');
                            return;
                        }
                        if (!textToConvert) {
                            alert('변환할 텍스트를 입력해주세요.');
                            return;
                        }

                        statusSpan.textContent = '변환 중...';
                        statusSpan.className = 'download-status pending';
                        downloadBtn.disabled = true;
                        audioPlayer.src = ''; // 기존 오디오 초기화

                        // 현재 전역 설정된 음성 파라미터 가져오기
                        const voiceName = voiceSelect.value;
                        const speakingRate = parseFloat(rateSlider.value);
                        const pitch = parseInt(pitchSlider.value);
                        const volumeGainDb = parseInt(volumeSlider.value);
                        const isChirpModel = voiceName.includes('Chirp3');

                        const requestOptions = {
                            textToConvert: textToConvert,
                            inputType: 'text', // 항상 일반 텍스트로 처리
                            voice: voiceName,
                            rate: speakingRate,
                            pitch: pitch,
                            volumeGainDb: volumeGainDb,
                            isChirpModel: isChirpModel
                        };

                        try {
                            const response = await synthesizeSpeech_local(apiKey, requestOptions);

                            if (response.error) {
                                statusSpan.textContent = `오류: ${response.error}`;
                                statusSpan.className = 'download-status error';
                                console.error('TTS 변환 오류:', response.details || response.error);
                                alert('음성 변환 중 오류가 발생했습니다: ' + response.error);
                            } else if (response.audioContent) {
                                const audioBlob = base64ToBlob_local(response.audioContent, 'audio/mpeg');
                                const audioUrl = URL.createObjectURL(audioBlob);
                                audioPlayer.src = audioUrl;
                                audioPlayer.load(); // 오디오 로드
                                statusSpan.textContent = '변환 완료! 재생 가능';
                                statusSpan.className = 'download-status success';
                                downloadBtn.disabled = false;
                                downloadBtn.onclick = () => {
                                    const a = document.createElement('a');
                                    a.href = audioUrl;
                                    a.download = `chunk_${segmentId + 1}_audio.mp3`;
                                    document.body.appendChild(a);
                                    a.click();
                                    document.body.removeChild(a);
                                    statusSpan.textContent += ' (다운로드 완료)';
                                    statusSpan.className = 'download-status success';
                                };
                            }
                        } catch (error) {
                            statusSpan.textContent = '네트워크 오류 또는 기타 문제';
                            statusSpan.className = 'download-status error';
                            console.error('TTS 변환 요청 실패:', error);
                            alert('음성 변환 요청 중 예상치 못한 오류가 발생했습니다.');
                        }
                    });
                });
            }
        });
    </script> 
</body>
</html>
